ABSTRACT

Academic assessment by conducting examinations and manually evaluating answers tend to be hectic, expensive and time-consuming. Human intervention in the entire process consumes instructors’ valuable time and can end up being biased intentionally or unintentionally. This project aims to build an automated software module to provide an inexpensive alternative to the current examination system. The software will assess students’ knowledge in the particular course by generating potential questions and evaluating the student’s understanding of the course


Chapter 1 Introduction
1.1 Introduction to Problem Domain
Examination systems were introduced into the education system as a metric of evaluating the learner understanding of the course but over time, the examination system became competitive in nature and it no more tends to properly evaluate the learner understanding of the course. Newer technologies and courses have arrived which help in understanding the concepts better, but there haven’t been any measures taken to ensure proper testing of his knowledge, without making it biased or unfair.

From framing questions to evaluating the learner's understanding of the subject everything today is mostly biased, unfair due to the human interference in the system. Sometimes tutors fail to frame questions and test the knowledge of the learner thoroughly on the entire subject, while sometimes the examination conduction is improper leading to malpractices while taking assessment and there are also the situations where tutors while evaluating bias some learners and thus making the whole system inefficient. 

A good assessment system should test the knowledge of the learner thoroughly in the course and should evaluate learner understanding using fair means. It must also ensure that the conduction of the assessment is undergone in a malpractice free environment, thus ensuring that the assessment is fair and giving the provision for the learner to learn from this assessment. Personal monitoring to assist the learner in understanding how the assessment has gone will motivate the student to improve better for further assessments and thus will also move him forward to learn the concept better. 

One such system, will thus eliminate the competitive nature of assessment with other students and rather inculcate the much needed competition of one with themselves to understand the course better and perform better in future assessments.
1.2 Purpose
The purpose of this software product is to ensure fair means of academic assessment without any human intervention to assess a student's core knowledge in a particular course. To reduce expenses associated with manual construction of questions and to eliminate biased evaluation owing to psychological changes of the evaluator.
1.3 Aim 
This project aims to build an automated software module to provide an inexpensive alternative to the current examination system. 
1.4 Objectives
1. Two interfaced platform for the tutor and students
2. Potential Question generation from subject material 
3. Ideal answer generation for potential questions 
4. Evaluating user responses with the ideal answers 
5. Basic proctoring to ensure fair means of conduction
1.5 Applications
To improve the way tests are conducted and evaluated. Automation ensures fairness and hence can be applied to any field that requires testing the knowledge of its peers.
1.6 Existing Solutions
The current examination system is conducted offline, in person, where the tutors who have trained the students in respective courses, prepare the questions to test the student knowledge in the particular courses and evaluate the student answers, rewarding them marks for their understanding of the course. 

On the other hand there is also an online mode of conduction of exams, where tutors who train students prepare the questions for respective courses and upload the same in a third party software, which are then randomly assigned to each student who takes up the assignment and responds to the assessments based on his understanding of the course. Later the responses collected by the third party software are evaluated again by the same tutor. 
1.7 Limitations of Existing System
The main limitations of the existing system is it’s total dependency on testing student knowledge in subject on handful tutors, who may or maynot question student knowledge on all aspects of the subject. Also, the tutors can be biased while correcting due to personal reasons or could be bribed to award higher scores. There’s also a possibility of tutors leaking question papers to the students to help them score higher and thus making the learning cycle inefficient to the students.



Chapter 3 : System Requirements and Analysis
3.1 Software Requirements
The system developed is architecture-neutral software and works on all systems like personal computers, mobile phones and tablets that support the latest versions of web browser applications(Firefox, Chrome, Microsoft Edge, Internet Explorer). The software developed is accessible to the end-user as a website, which is responsive allowing the user to run it on all devices, without hampering the user experience, it follows all the website accessibility guidelines and is protected by an SSL certificate. 


3.3 Functional Requirements
3.3.1 User Login Handling 
User login handling is an integral part of the application as it determines what each specific user should be able to see. With the aid of user login handling, we should be able to authenticate and authorize a user. The objective of this requirement is to obtain data encapsulation, integrity and abstraction. 
3.3.2 Automated Question Generation from Subject Material 
Automated Question Generation from subject material serves as the heart of the software application, which gives the user a fair means of testing the depth of understanding one has to the course enrolled. It allows the user to be tested on objective as well as subjective questions covering all grounds of testing.
3.3.3 User Performance Evaluation 
User Performance Evaluation is the metric used to assess student understanding in the subject. This module evaluates the user responses and generates a score. 
3.3.4 Data Security
Data security is a vital part of every application. Data security is proposed to be attained in the application by using end to end encryption. Additionally, privileged access to database transactions ensures the data is secure.
3.4 Non-Functional Requirements
3.4.1 Performance Requirements 
The software system must be interactive and the delay involved must be minimalistic. So all the action-responses of the system must have no immediate delays. The maximum permissible delay in each of the actions such as opening window forms, popping error messages, opening databases, sorting questions, evaluation of responses and saving the settings or sessions is 2 seconds. Also when connecting to the server the latency allowed is based on the distance of the 2 systems and the configuration between them so that there is a high probability that there will be or not a successful connection in less than 20 seconds for sake of good communication.
3.4.2 Safety Requirements 
The system is to be safely hosted in a cloud-driven environment with a Secure Sockets Layer(SSL) certificate which is a digital certificate that authenticates a website's identity and enables an encrypted socket connection between the client and server.
3.4.3 Security Requirements 
The user information is kept private and inaccessible for other user classes to ensure user privacy. All data of user profiling is permitted with write-only access to the user with valid credentials only, thus ensuring a fail-safe default that doesn’t compromise on user data even in case the credentials are compromised.





Chapter 4 : Tools & Technologies
4.1 Python Flask Framework
Flask is a micro web framework written in Python. It is classified as a microframework because it does not require particular tools or libraries. It has no database abstraction layer, form validation, or any other components where pre-existing third-party libraries provide common functions. Flask is used for developing web applications using python, implemented on Werkzeug and Jinja2. Advantages of using Flask framework are: There is a built-in development server and a fast debugger provided.
4.2 HTML
The HyperText Markup Language or HTML is the standard markup language for documents designed to be displayed in a web browser. Web browsers receive HTML documents from a web server or from local storage and render the documents into multimedia web pages. HTML describes the structure of a web page semantically and originally included cues for the appearance of the document.
4.3 CSS
Cascading Style Sheets (CSS) is a style sheet language used for describing the presentation of a document written in a markup language such as HTML. CSS has a simple syntax and uses a number of English keywords to specify the names of various style properties.CSS makes the front-end of a website shine and it creates a great user experience.
4.4 Vanilla JavaScript
Vanilla JavaScript refers to using plain Javascript without any additional libraries or frameworks. Vanilla JS is a fast, lightweight, cross-platform framework for building incredible, powerful JavaScript applications.  Vanilla Js is the purest form of Javascript with no addition of any library and using the inbuilt functions/methods and objects. Hence it makes the application framework free and without any dependencies.
4.5 Backend - Python 
Back-end technologies form the fundamental backbone of every tech stack. Python is renowned for its simple syntax and shortcode length. Moreover, Python being extremely well-designed and versatile is a platform-independent language and can be used on a wide variety of operating systems. Python has several powerful libraries with a huge amount of pre-written code. Hence developers don't need to write the code from scratch, thereby speeding up the development time. This makes it an ideal choice to use Python for backend development.
4.6 Database - FlaskSQLAlchemy
Flask-SQLAlchemy is an extension for Flask that aims to simplify using SQLAlchemy with Flask by providing defaults and helpers to accomplish common tasks. One of the most sought after helpers being the handling of a database connection across the app.
4.7 AI-ML - BERT Model 
BERT, which stands for Bidirectional Encoder Representations from Transformers, is based on Transformers, a deep learning model in which every output element is connected to every input element, and the weightings between them are dynamically calculated based upon their connection.
4.8 Natural Language Toolkit(NLTK)
The Natural Language Toolkit, is a suite of libraries and programs for symbolic and statistical natural language processing for English written in the Python programming language. NLTK is a standard python library that provides a set of diverse algorithms for NLP. It is one of the most used libraries for NLP and Computational Linguistics
4.9 Visual Studio Code(VS Code)
Visual Studio Code, also commonly referred to as VS Code, is a source-code editor made by Microsoft for Windows, Linux and macOS. Features include support for debugging, syntax highlighting, intelligent code completion, snippets, code refactoring, and embedded Git. VS Code includes enriched built-in support for Node. js development with JavaScript and TypeScript, powered by the same underlying technologies that drive Visual Studio. VS Code also includes great tooling for web technologies such as JSX/React, HTML, CSS, SCSS, Less, and JSON.
4.10 Google Colab
Google Colab allows anybody to write and execute arbitrary python code through the browser, and is especially well suited to machine learning, data analysis and education. Google Colab is an excellent tool for deep learning tasks. It is a hosted Jupyter notebook that requires no setup and has an excellent free version, which gives free access to Google computing resources such as GPUs and TPUs.




As per the flow diagram given in above, the platform is initiated with a tutor uploading the respective subject material required for the working of the software. Followed by this, the student assessments are made available to use. To generate the assessments we need to form the question - answer pairs. Firstly, we have two main types of question framing, objective questions and subjective questions. Furthermore, the objective questions are classified as fill in the blanks type questions and multiple-choice questions. Similarly, the subjective questions are classified as long questions and short questions to award marks based on the content that can be reproduced on those questions. Once the questions are generated, we need to figure out the answer pairs for all the above questions and specially for MCQ type questions, we must not stop at answer generation but also create options that are similar to the actual answer which can create confusion amongst the students thus testing their ability to the fullest. After generation of the question-answer pair, we collect the user responses for all the questions in the assessment and evaluate their responses with the ideal answers generated for respective questions. Based on how similar the student response and the ideal answers are, a score is generated for the student to assess his performance in the assessment. 

5.2 System Architecture

The essential modules in the development of this AI-Based software are : 
Subject Material - All the operations are solely dependent on the text input that is fed to the software. It is very essential for the subject material uploaded to be very clear and contain as many informative sentences as possible so that more potential questions can be formed to assess the student fairly. 

Objective Question Answer Generation - The question-answer generation procedure for objective and subjective assessments vary from each other. In the objective question answer generation, our aim is to map keywords extracted from the subject material and form questions that are suitable with the keyword as the answer. User uploads corpus. The corpus is broken down into smaller chunks of text which is then summarized. Keywords are extracted from the summarized text and tokens are generated. Keywords are mapped with extracted sentences to form objective questions.

Subjective Question Answer Generation - Unlike objective question answer generation, we can’t frame questions just based on keywords. The corpus is broken down into smaller chunks of text which is then summarized. Keywords are extracted from the summarized text and tokens are generated. Parse tree is generated with the tokens and weights are added to each subtree. Questions are framed using each of these subtrees.


Answer Evaluation - Evaluating the answer is the most important part of the project as it is a metric that is used to measure the student understanding and knowledge of the subject. It is the assessment metric used, so we must ensure that the value obtained in manual evaluation isn’t different from the automated machine evaluation. For the objective questions, it won’t be a hassle as it just needs to validate if the response and ideal answer match, if it does they are awarded respective points. But the subjective evaluation deals with partial marking based on how similar the answer is to the ideal answer

5.3 Use Cases and Characteristics
There are two user classes in this software, the Student class and the Tutor class. The Student class allows every student to assess their knowledge in particular courses across different modes of examination(subjective and objective). The user performance is evaluated in the course based on a score generated for the responses submitted by the user. 

Similarly, a Tutor class is for tutors of a particular course, who upload relevant subject material for the software to interpret the material and generate tests based on them. 

5.4 Database Schema 

The database contains 3 tables namely Students, Tests and Users.


Users - Stores user credentials, password is hashed for security
Students - Stores information about a student, the tests attempted by the student and the scores generated for attempted tests
Tests - Stores information about all the tests conducted so far 
